#Script name- generate_moirai_spatial
#Authors- Kanishka Narayan and Alan DiVittorio
#Date created- 10th August 2020
#Description- Combine different boundaries with MOIRAI land data to get combined shape files

# script settings are in lines 58-95
# make sure that these entries are correct, particularly gcam_glu_data_file, use_osgeo, osgeopath, pypath, gdalpolygonize_path, and out_dir

# this script takes about 15-20 minutes to run

# Moirai Land Data System (Moirai) Copyright (c) 2020, The
# Regents of the University of California, through Lawrence Berkeley National
# Laboratory (subject to receipt of any required approvals from the U.S.
# Dept. of Energy).  All rights reserved.

# If you have questions about your rights to use or distribute this software,
# please contact Berkeley Lab's Intellectual Property Office at
# IPO@lbl.gov.

# NOTICE.  This Software was developed under funding from the U.S. Department
# of Energy and the U.S. Government consequently retains certain rights.  As
# such, the U.S. Government has been granted for itself and others acting on
# its behalf a paid-up, nonexclusive, irrevocable, worldwide license in the
# Software to reproduce, distribute copies to the public, prepare derivative
# works, and perform publicly and display publicly, and to permit other to do
# so.

# This file is part of Moirai.

# Moirai is free software: you can use it under the terms of the modified BSD-3 license (see â€¦/moirai/license.txt)

#Load libraries
library(rgdal)
library(raster)
library(sp)
library(sf)
library(dplyr)
library(data.table)
library(nngeo)
library(smoothr)
library(ggplot2)
library(rgeos)

# make sure working directory is .../moirai/diagnostics/
setwd("./")

#Load helper function to get raster data
get_and_standardize_raster <- function(raster_path= "spatial_input_files/country_out.bil",
                                       crs_for_proj= "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0",
                                       raster_extent=NULL){

  raster_binary<-NULL

  raster_binary <- raster(raster_path)
  raster::projection(raster_binary)<-crs_for_proj
  raster::extent(raster_binary)<-raster_extent

  return(raster_binary)
}

## this is a moirai output file for validation plots (this default is for 235 basin GLUs)
moirai_land_type_area_file <- "spatial_input_files/Land_type_area_ha.csv"

# files for the metadata section
gcam_glu_data_file <- "spatial_input_files/Global235_CLM_5arcmin.csv"
gcam_region_name_file <- "spatial_input_files/GCAM_region_names.csv"
gcam_iso_reg_id_file <-  "spatial_input_files/FAO_iso_VMAP0_ctry.csv"

## parameters and paths for the gdal polygonize section
use_osgeo <- TRUE

#Default osgeopath is set to the C: drive. MAC users can use gdal_polygonize instead
osgeopath <- "c:/OSGeo4W64/OSGeo4W.bat"

#If you have OGSEO, no need to change the python and gdal_polygonize.py paths
# make sure to include the space at the end of gdalpolygonize_path
pypath <-"python"
gdalpolygonize_path <- "/Library/Frameworks/GDAL.Framework/Programs/gdal_polygonize.py "

## output directory

# do not include the final "/" in out_dir
out_dir = "basins235_example_outputs_spatial_output_files"

#This is the threshold in m2 above which all holes will be filled in the vector files.
hole_filling_threshold <- 1e+19

## Following combinations can be generated by the code.
#1. country
#2. region
#3. glu
#4. ctry_glu
#5. reg_glu
#6. reg_ctry
raster_combinations <- c("country","region","glu","ctry_glu","reg_glu","reg_ctry")

## When writing the function, use this value for nodata
no_data_value_moirai <- -9999

out_rast_dir = paste0(out_dir, "/raster_files/")
out_map_dir = paste0(out_dir, "/mapping_files/")
out_raw_dir = paste0(out_dir, "/raw_shape_files/")
out_bndry_dir = paste0(out_dir, "/gcam_boundaries_moirai_3p1_0p5arcmin_wgs84/")
out_val_dir = paste0(out_dir, "/validation_figs/")

dir.create(out_dir, showWarnings = FALSE)
#Create directories to store files
dir.create(out_rast_dir, showWarnings = FALSE)
dir.create(out_map_dir, showWarnings = FALSE)
dir.create(out_raw_dir, showWarnings = FALSE)
dir.create(out_bndry_dir, showWarnings = FALSE)
dir.create(out_val_dir, showWarnings = FALSE)

#Declare all variables
Land_Data_Binary<-GLU<-GLU_Data<-shp_metadata<-shp_file<-shape_data<-shape_data_region<-shape_data_country<-Land_Data_Actual<-GLU_Data_Join<-
  GLU_Data_Join_Noland<-GLU_raster<-t<-t_noland<-NULL

# projection parameters
moirai_projection <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"

#Get all valid boundaries from moirai (these defaults are fore 235 basin GLUs)
moirai_land_raster_path <-'spatial_input_files/valid_land_area.bil'
moirai_ctry_land <- 'spatial_input_files/country_out.bil'
moirai_ctry_noland <- 'spatial_input_files/country_out_noland.bil'
moirai_basin_land <-  'spatial_input_files/glu_raster.bil'
moirai_basin_noland <- 'spatial_input_files/glu_raster_noland.bil'
moirai_region_land <-   'spatial_input_files/region_gcam_out.bil'
moirai_region_noland <-  'spatial_input_files/region_gcam_out_noland.bil'


#--------------Step 1: Get land raster data from MOIRAI------------------------------------------------
#Get land data binary
Land_Data_Binary <- raster(moirai_land_raster_path)


#Get all boundaries for land cells
GLU_land_raster <- get_and_standardize_raster(raster_path = moirai_basin_land,
                                              crs_for_proj = moirai_projection,
                                              raster_extent = extent(Land_Data_Binary))

country_land_raster <- get_and_standardize_raster(raster_path = moirai_ctry_land,
                                                  crs_for_proj = moirai_projection,
                                                  raster_extent = extent(Land_Data_Binary))

region_land_raster <- get_and_standardize_raster(raster_path = moirai_region_land,
                                                 crs_for_proj = moirai_projection,
                                                 raster_extent = extent(Land_Data_Binary))


GLU_land_data <- as.data.table(rasterToPoints(GLU_land_raster))
rm(GLU_land_raster)
gc()
country_land_data <- as.data.table(rasterToPoints(country_land_raster))
rm(country_land_raster)
gc()
region_land_data <- as.data.table(rasterToPoints(region_land_raster))
rm(region_land_raster)
gc()

#bind columns. This will create multiple columns, but that is fine since these are all standardized rasters.
#The test below checks that all values are identical.
land_cells_all_boundaries <- dplyr::bind_cols(GLU_land_data,country_land_data,region_land_data,.name_repair = c("unique"))

if(!identical(land_cells_all_boundaries$x...1,land_cells_all_boundaries$x...4,land_cells_all_boundaries$x...7)){stop("rasters are mismatched")}
if(!identical(land_cells_all_boundaries$y...2,land_cells_all_boundaries$y...5,land_cells_all_boundaries$y...8)){stop("rasters are mismatched")}

rm(region_land_data,GLU_land_data,country_land_data)
gc()

  land_cells_all_boundaries %>%
  dplyr::rename(x=x...1,y=y...2) %>%
  dplyr::select(x,y,glu_raster,country_out,region_gcam_out) %>%
  filter(glu_raster != no_data_value_moirai, country_out != no_data_value_moirai,region_gcam_out != no_data_value_moirai) %>%
  rename(country=country_out,region=region_gcam_out,glu=glu_raster) %>%
  mutate(ctry_glu=country*1000+glu,
         reg_glu=region*1000+glu,
         reg_ctry=region*1000+country)->land_cells_all_boundaries



land_cells_all_boundaries <- as.data.frame(land_cells_all_boundaries)

#Now get data for valid boundaries for non-land-cells
GLU_no_land_raster <- get_and_standardize_raster(raster_path = moirai_basin_noland,
                                                 crs_for_proj = moirai_projection,
                                                 raster_extent = extent(Land_Data_Binary))

country_no_land_raster <- get_and_standardize_raster(raster_path = moirai_ctry_noland,
                                                     crs_for_proj = moirai_projection,
                                                     raster_extent = extent(Land_Data_Binary))

region_no_land_raster <- get_and_standardize_raster(raster_path = moirai_region_noland,
                                                    crs_for_proj = moirai_projection,
                                                    raster_extent = extent(Land_Data_Binary))



GLU_noland_data <- as.data.table(rasterToPoints(GLU_no_land_raster))
rm(GLU_no_land_raster)
gc()
country_noland_data <- as.data.table(rasterToPoints(country_no_land_raster))
rm(country_no_land_raster)
gc()
region_noland_data <- as.data.table(rasterToPoints(region_no_land_raster))
rm(region_no_land_raster)
gc()

nonland_cells_all_boundaries <- bind_cols(GLU_noland_data,country_noland_data,region_noland_data)

if(!identical(nonland_cells_all_boundaries$x...1,nonland_cells_all_boundaries$x...4,nonland_cells_all_boundaries$x...7)){stop("rasters are mismatched")}
if(!identical(nonland_cells_all_boundaries$y...2,nonland_cells_all_boundaries$y...5,nonland_cells_all_boundaries$y...8)){stop("rasters are mismatched")}

rm(GLU_noland_data,country_noland_data,region_noland_data)
gc()

  nonland_cells_all_boundaries %>%
  dplyr::rename(x=x...1,y=y...2) %>%
  dplyr::select(x,y,glu_raster_noland,country_out_noland,region_gcam_out_noland) %>%
  filter(glu_raster_noland != no_data_value_moirai, country_out_noland != no_data_value_moirai,region_gcam_out_noland != no_data_value_moirai) %>%
  rename(country=country_out_noland,region=region_gcam_out_noland,glu=glu_raster_noland) %>%
  mutate(ctry_glu=country*1000+glu,
         reg_glu=region*1000+glu,
         reg_ctry=region*1000+country)->nonland_cells_all_boundaries

nonland_cells_all_boundaries <- as.data.table(nonland_cells_all_boundaries)



#3 Now get land data
Land_Data_Actual <- (as.data.table(rasterToPoints(Land_Data_Binary)))

#Check that we got all land cells
tmp<-Land_Data_Actual %>% filter(valid_land_area>0) %>% left_join(land_cells_all_boundaries,by=c("x","y"))
tmpna<-tmp[is.na(tmp$ctry_glu),]

if(nrow(tmpna)>0){

  stop("valid hyde land area does not match boundaries. Check the input data")
}

#Free some space
rm(tmp)
rm(tmpna)
gc()

#Use this loop to generate the final rasters for land and no land
#1. country
#2. region
#3. glu
#4. ctry_glu
#5. reg_glu
#6. reg_ctry


data_for_mapping<- bind_rows(land_cells_all_boundaries,nonland_cells_all_boundaries)

for(i in raster_combinations){


  land_cells_all_boundaries %>%
    dplyr::select(all_of(i),x,y) %>%
    rename(key=all_of(i)) %>%
    mutate(key=as.integer(key)) %>%
    distinct()->GLU_Data_Join

  nonland_cells_all_boundaries %>%
    dplyr::select(all_of(i),x,y) %>%
    rename(key=all_of(i)) %>%
    mutate(key=as.integer(key)) %>%
    distinct()->GLU_Data_Join_Noland


  data_for_mapping %>%
    distinct() %>%
    mutate(ctry_id=country,glu_id=glu,reg_id=region) %>%
    rename(key=all_of(i)) %>%
    mutate(key=as.integer(key)) %>%
    dplyr::select(key,ctry_id,glu_id,reg_id,x,y)->mapping_data

  write.csv(mapping_data,paste0(out_map_dir,toString(i),"_mapping.csv"),row.names = FALSE)


  #Land
  coordinates(GLU_Data_Join)<-~x+y
  gridded(GLU_Data_Join)<-TRUE
  GLU_raster <-raster(GLU_Data_Join)
  raster::projection(GLU_raster)<-"+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
  GLU_raster<-raster::extend(GLU_raster,Land_Data_Binary)
  writeRaster(GLU_raster, filename=tolower(paste0(out_rast_dir, "gcam_",toString((i)),"_boundaries_moirai_land_cells_3p1_0p5arcmin.tif")), format="GTiff", overwrite=TRUE)

  #No land
  coordinates(GLU_Data_Join_Noland)<-~x+y
  gridded(GLU_Data_Join_Noland)<-TRUE
  GLU_raster <-raster(GLU_Data_Join_Noland)
  raster::projection(GLU_raster)<-"+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
  GLU_raster<-raster::extend(GLU_raster,Land_Data_Binary)
  writeRaster(GLU_raster, filename=tolower(paste0(out_rast_dir, "gcam_",toString((i)),"_boundaries_moirai_no_land_3p1_0p5arcmin.tif")), format="GTiff", overwrite=TRUE)

  #Combined
  GLU_Combined <- rbind(GLU_Data_Join_Noland,GLU_Data_Join)
  gridded(GLU_Combined)<-TRUE
  GLU_raster <-raster(GLU_Combined)
  raster::projection(GLU_raster)<-"+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
  GLU_raster<-raster::extend(GLU_raster,Land_Data_Binary)
  writeRaster(GLU_raster, filename=tolower(paste0(out_rast_dir, "gcam_",toString((i)),"_boundaries_moirai_Combined_3p1_0p5arcmin.tif")), format="GTiff", overwrite=TRUE)


  print(paste0("Done generating rasters for land ,no land and combined for ",toString(i)))

} # end for i loop over output boundary combinations

#Remove data to free space
rm(GLU_Data_Join)
rm(GLU_Data_Join_Noland)
rm(GLU_raster)


#--------------#Step 2: Get raw shape files from rasters using polygonization code------------------------------------------------

raster_file_names <-list.files(path=out_rast_dir, full.names=FALSE, pattern = ".tif")

for (i in raster_file_names){

  raster_name <- gsub(".tif","",i)

  #If OSGEO is installed use it or use gdal_polygonize.py instead.
  if(use_osgeo){

    system2(osgeopath,paste0("gdal_polygonize ", out_rast_dir, toString(raster_name), ".tif ", out_raw_dir, toString(raster_name), ".shp key key"))
  }else{

    system2(pypath, paste0(gdalpolygonize_path,out_rast_dir, toString(raster_name), ".tif -f 'ESRI Shapefile' ", out_raw_dir, toString(raster_name), ".shp key key"))

  }
  print(paste0("Completed processing shapefile- ",toString(raster_name),".shp"))
}

#------------------------Step 3: Add metadata-------------------------------------------------

#Get additional metadata: GCAM_region names
#Skip metadata rows when reading in csv
GCAM_region_names<-read.csv(gcam_region_name_file,skip = 4, stringsAsFactors = FALSE) %>% rename(reg_id=GCAM_region_ID,reg_nm=region)
#Get additional metadata: basin_names
#Skip metadata rows when reading in csv
ISO_GCAM_REG_ID<-read.csv(gcam_iso_reg_id_file, stringsAsFactors = FALSE) %>%
  rename(ctry_id=fao_code,ctry_nm=vmap0_name) %>%
  dplyr::select(ctry_nm,ctry_id) %>%
  mutate(ctry_nm=if_else(ctry_id==186,"Serbia and Montenegro",ctry_nm)) %>%
  distinct()


ctry_data<-ISO_GCAM_REG_ID %>% mutate(key=ctry_id)

reg_data <- GCAM_region_names %>% mutate(key=reg_id)

# need to distinguish between basin and aez input
basin_data<-read.csv(gcam_glu_data_file, stringsAsFactors = FALSE)
if(names(basin_data)[1] == "AEZ_ID") {
	basin_data<-basin_data %>%
  		rename(glu_nm=AEZ_NAME,glu_id=AEZ_ID) %>%
  		mutate(key=glu_id) %>%
  		dplyr::select(key,glu_id,glu_nm) %>%
  		distinct()
} else if (names(basin_data)[1] == "GCAM_ID_1") {
	basin_data<-basin_data %>%
  		rename(glu_nm=Basin_na_1,glu_id=GCAM_ID_1) %>%
  		mutate(key=glu_id) %>%
  		dplyr::select(key,glu_id,glu_nm) %>%
  		distinct()
} else {
	stop(paste("Unrecognized set of GLU names in file:", gcam_glu_data_file))
}

# the intersected boundary files need some additional data, but make sure they exist

if (file.exists(paste0(out_map_dir, "ctry_glu_mapping.csv"))){
ctry_glu_data<-read.csv(paste0(out_map_dir, "ctry_glu_mapping.csv"),stringsAsFactors = FALSE) %>%
  dplyr::select(ctry_id,glu_id,key) %>%
  distinct() %>%
  left_join(ctry_data %>% dplyr::select(ctry_id,ctry_nm),by=c("ctry_id")) %>%
  left_join(basin_data%>% dplyr::select(glu_id,glu_nm),by=c("glu_id")) %>%
  dplyr::select(glu_nm,ctry_nm,key,glu_id,ctry_id) %>%
  distinct()
}

if (file.exists(paste0(out_map_dir, "reg_glu_mapping.csv"))){
reg_glu_data<-read.csv(paste0(out_map_dir, "reg_glu_mapping.csv"),stringsAsFactors = FALSE) %>%
  dplyr::select(reg_id,glu_id,key) %>%
  distinct() %>%
  left_join(basin_data%>% dplyr::select(glu_id,glu_nm),by=c("glu_id")) %>%
  left_join(reg_data%>% dplyr::select(reg_id,reg_nm),by=c("reg_id")) %>%
  dplyr::select(key,glu_nm,reg_nm,glu_id,reg_id) %>%
  distinct()
}

if (file.exists(paste0(out_map_dir, "reg_ctry_mapping.csv"))){
reg_ctry_data<-read.csv(paste0(out_map_dir, "reg_ctry_mapping.csv"),stringsAsFactors = FALSE) %>%
  dplyr::select(reg_id,ctry_id,key) %>%
  mutate(reg_id=as.integer(reg_id),ctry_id=as.integer(ctry_id)) %>%
  distinct() %>%
  left_join(ctry_data%>% dplyr::select(ctry_id,ctry_nm),by=c("ctry_id")) %>%
  left_join(reg_data%>% dplyr::select(reg_id,reg_nm),by=c("reg_id")) %>%
  distinct()
}

#Get all filenames
file_names<- list.files(path=out_raw_dir, full.names=FALSE, pattern = ".shp")

for (i in file_names){
  Final_shape_file<- shapefile(toString(paste0(out_raw_dir,i)))

  file_name<-gsub("gcam_","",i)
  file_name<-gsub(".shp","",file_name)
  print(paste0("Completed processing ",toString(file_name)))
  Final_shape_file <- st_as_sf(Final_shape_file)

  #If its a combined file,fill holes
  if(grepl("combined",file_name)){

    Final_shape_file<-smoothr::fill_holes(Final_shape_file, threshold = hole_filling_threshold)
  }

  if (grepl("country",file_name)){
    Final_shape_file %>% inner_join(ctry_data, by=c("key"))->Final_shape_file
    #Check for NAs in country names
    tmpna<-Final_shape_file[is.na(Final_shape_file$ctry_nm),]
    # Note that first 10 rows are meatadata rows. Hence the code checks for rows higher than 10.
    if (length(tmpna)>10){

      print(paste0("Na values found in ",toString(i)))
      print(tmpna)
    }

  } # end if grep country


  if (grepl("glu",file_name) & !grepl("ctry_glu",file_name) & !grepl("reg_glu",file_name)){
    Final_shape_file %>% inner_join(basin_data, by=c("key"))->Final_shape_file
    #Check for NAs in basin names
    tmpna<-Final_shape_file[is.na(Final_shape_file$glu_nm),]
    # Note that first 10 rows are meatadata rows. Hence the code checks for rows higher than 10.

    if (length(tmpna)>10){
      print(paste0("Na values found in ",toString(i)))
      print(tmpna)
    }

  } # end if grep glu and not ctry_glu or reg_glu


  if (grepl("region",file_name)){
    Final_shape_file %>% inner_join(reg_data, by=c("key"))->Final_shape_file
    #Check for NAs in region names
    tmpna<-Final_shape_file[is.na(Final_shape_file$reg_nm),]
    # Note that first 10 rows are meatadata rows. Hence the code checks for rows higher than 10.
    if (length(tmpna)>10){
      print(paste0("Na values found in ",toString(i)))
      print(tmpna)
    }
  } # end if grep region

  if (grepl("ctry_glu",file_name)){

    Final_shape_file %>% inner_join(ctry_glu_data, by=c("key"))->Final_shape_file
    # Note that first 10 rows are meatadata rows. Hence the code checks for rows higher than 10.
    #Check for NAs in country names
    tmpna<-Final_shape_file[is.na(Final_shape_file$ctry_nm),]
    if (length(tmpna)>10){
      print(paste0("Na values found in ",toString(i)))
      print(tmpna)
    }
    #Check for NAs in basin names
    tmpna<-Final_shape_file[is.na(Final_shape_file$glu_nm),]
    if (length(tmpna)>10){
      print(paste0("Na values found in ",toString(i)))
      print(tmpna)
    }

  } # end if grep ctry_glu


  if (grepl("reg_glu",file_name)){
    #Check for NAs in region names
    Final_shape_file %>% inner_join(reg_glu_data, by=c("key"))->Final_shape_file
    # Note that first 10 rows are meatadata rows. Hence the code checks for rows higher than 10.
    tmpna<-Final_shape_file[is.na(Final_shape_file$reg_nm),]
    if (length(tmpna)>10){
      print(paste0("Na values found in ",toString(i)))
      print(tmpna)
      print(length(tmpna))
    }
    #Check for NAs in basin names
    tmpna<-Final_shape_file[is.na(Final_shape_file$glu_nm),]
    if (length(tmpna)>10){
      print(paste0("Na values found in ",toString(i)))
      print(tmpna)
    }

  } # end if grep reg_glu

  if (grepl("reg_ctry",file_name)){

    Final_shape_file %>% inner_join(reg_ctry_data, by=c("key"))->Final_shape_file
    # Note that first 10 rows are metadata rows. Hence the code checks for rows higher than 10.
    #Check for NAs in country names
    tmpna<-Final_shape_file[is.na(Final_shape_file$ctry_nm),]
    if (length(tmpna)>10){
      print(paste0("Na values found in ",toString(i)))
      print(tmpna)
    }
    #Check for NAs in region names
    tmpna<-Final_shape_file[is.na(Final_shape_file$reg_nm),]
    if (length(tmpna)>10){
      print(paste0("Na values found in ",toString(i)))
      print(tmpna)
    }
  } # end if grep reg_ctry

  #Test for 2 exceptions: 3 sided polygons, self intersections
  exceptions<-st_is_valid(Final_shape_file,NA_on_exception = TRUE)
  na_exceptions<-exceptions[is.na(exceptions)]
  self_intersections <-exceptions[exceptions=="FALSE"]

  if(length(na_exceptions)>0){
    print("Fixing invalid geometries")
    Final_shape_file<-st_make_valid(Final_shape_file)

  }

  if(length(self_intersections)>0){
    print("Fixing self intersections")
    Final_shape_file<-st_make_valid(Final_shape_file)
  }

  #Final clean ups
  file_name <- gsub("land_cells","landcells",file_name)
  file_name <- gsub("no_land","noland",file_name)

  Final_shape_file <- as(Final_shape_file,"Spatial")
  Final_shape_file <- raster::aggregate(Final_shape_file,names(Final_shape_file))
  writeOGR(Final_shape_file, dsn = paste0(out_bndry_dir,toString(file_name),".shp"), layer = toString(file_name), driver = "ESRI Shapefile",overwrite_layer = TRUE)

} # end i loop over raw files

#Generate validation plots


basin_shp_file <- st_read(paste0(out_bndry_dir, "glu_boundaries_moirai_landcells_3p1_0p5arcmin.shp"))
basin_shp_file$geom_area<-st_area(basin_shp_file$geometry)*0.0001

Land_raster_data<-read.csv(moirai_land_type_area_file, skip = 5, stringsAsFactors = FALSE) %>%
  filter(year==2010) %>%
  group_by(glu_code) %>%
  mutate(land_area=sum(value)) %>%
  ungroup() %>%
  dplyr::select(glu_code,land_area) %>%
  rename(glu_id=glu_code) %>%
  distinct()

Land_raster_data %>%
  left_join(basin_shp_file %>% dplyr::select(glu_id,geom_area),by=c("glu_id")) %>%
  mutate(basin_area=as.double(geom_area)) %>%
  mutate(Diff=land_area-basin_area) %>%
  mutate(Percent_diff=(Diff/land_area)*100)->Data_for_Comparison

Anomalies <- Data_for_Comparison %>% filter(Diff>0) %>% filter(Percent_diff>1)

if(nrow(Anomalies)>0){
  print("Terrain area is higher than geometric area beyond the threshold. Please check the shapefiles")

}


g<-ggplot(Data_for_Comparison,aes(x=land_area,y=basin_area)) +
  geom_point()+
  xlab("Land area from moirai in ha")+
  ylab("Area calculated from polygons in ha")+
  ggtitle("Scatterplot showing area calculated from polygons and actual area for all GLUs")

scheme_basic <- theme_bw() +
  theme(legend.text = element_text(size = 10, vjust = 0.5)) +
  theme(legend.title = element_text(size = 10, vjust = 2)) +
  theme(axis.text = element_text(size = 10)) +
  theme(axis.title = element_text(size = 10, face = "bold")) +
  theme(plot.title = element_text(size = 10, face = "bold", vjust = 1)) +
  theme(plot.subtitle = element_text(size = 8, face = "bold", vjust = 1))+
  theme(strip.text = element_text(size = 7))+
  theme(strip.text.x = element_text(size = 8, face = "bold"))+
  #theme(legend.position = "bottom")+
  theme(legend.text = element_text(size = 10))+
  theme(legend.title = element_text(size = 10,color = "black",face="bold"))+
  theme(axis.text.x= element_text(angle=60,hjust=1))+
  theme(legend.background = element_blank(),
        legend.box.background = element_rect(colour = "black"))

g+scheme_basic
ggsave( paste0(out_val_dir, "Comparison_of_area_at_GLU_level", ".png"), width = 10, height = 6)


#----------------------------------------END-----------------------------------



